const fs = require('fs');
const Promise = require("bluebird");
const Mustache = require("mustache");

const readFile = Promise.promisify(require("fs").readFile);
const exec = Promise.promisify(require('child_process').exec);
const writeFile = Promise.promisify(require('fs').writeFile);
const AWS = require('aws-sdk');
const os = require('os');
const path = require('path');
const YAML = require('yamljs');


/**
 *
 * @param options {object} Config object
 * @param options.inputFile {string} Patht the file with the template to use as input
 * @param options.action {string} Can be "createStack" or "updateStack"
 * @param options.dryRun {boolean} default TRUE. Call AWS CLoudFormation only if set to false
 * @param options.aws_profile {string} The profile to use for AWS service calls
 * @constructor
 */
function NodeCF(options) {
    this.options = options;


    /*
     readFile() --> ritorna {contents, metadata}
     loadExternals()
     render()
     saveToTemp()
     createCf()

     */
}

/**
 * Read the input files and return the template generated by mustache
 */
NodeCF.prototype.buildTemplate = function () {

    const readFile = (/ya?ml/.test(path.extname(this.options.inputFile)))?this.readFileYaml:this.readFileJson;

    return readFile(this.options.inputFile)
        .then(data => {return this.loadExternals(this.options.inputFile, data)})
        .then(data => {

            // "stages" are particular elements that we want to add to the template metadata.
            // The template may specify additional stages
            data.metadata.aws.template.stages = [].concat(data.metadata.aws.template.stages || [], this.options.stages || []);

            // Stages can be used in the template metadata itself, so pass the to mustache
            data.metadata = JSON.parse(Mustache.render(JSON.stringify(data.metadata),data.metadata.aws.template));   // Al limite dell'incesto....

            if(data.metadata.aws.capabilities && typeof data.metadata.aws.capabilities === 'string') {
                data.metadata.aws.capabilities = data.metadata.aws.capabilities.split(" ");
            }

            return data;
        })
        .then(this.render)
};

NodeCF.prototype.validateTemplate = function(data) {
    const {metadata, contents} = data;
    if(this.options.aws_profile) {
        AWS.config.credentials = new AWS.SharedIniFileCredentials({profile: this.options.aws_profile});
    }

    return new AWS.CloudFormation({ region: metadata.aws.region }).validateTemplate({
        TemplateBody: contents
    }).promise().then(() => {return data;});
};

/**
 * Credentials are taken (in order, )
 * - this.aws_profile (http://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/loading-node-credentials-shared.html)
 *
 * The stack name is
 * - the name of the folder that contains the template, or
 * - Metadata.aws.template.name
 *
 * Currently a template can't be larger than 51kB
 *
 * @param template {String} The rendered template
 */

NodeCF.prototype.saveToCloudFormation = function(data) {

    const {metadata, contents} = data;
    const templateMeta = metadata;

    if(!templateMeta.aws.template.name) {
        return Promise.reject(new Error("[BadTemplate] Required field 'Metadata.aws.template.name' not found"))
    }

    if(this.options.dryRun) {
        console.log("!!! DryRun !!!");
        return Promise.resolve(data);
    }

    if(this.options.aws_profile) {
        AWS.config.credentials = new AWS.SharedIniFileCredentials({profile: this.options.aws_profile});
    }

    const StackName =  templateMeta.aws.template.name; // || path.dirname(templateFile).split(path.sep).pop().match(/(?=[a-z]).*/)[0];
    const TemplateBody = contents;

    return new AWS.CloudFormation({ region: templateMeta.aws.region })[this.options.action]({
        StackName,
        Capabilities: templateMeta.aws.capabilities,
        TemplateBody
    }).promise();
};

/**
 *
 * @param template {string} The template
 * @return {Promise.<{template: string the template, tempFile: string path to the temp file}>}
 */
NodeCF.prototype.saveTempalteToTempFile = function(data){
    const {metadata, contents} = data;
    const tempFile = [os.tmpdir(), path.sep, new Date().getTime(), '_template'].join('');

    console.log(`Template rendered in ${tempFile}`);
    return writeFile(tempFile, contents, 'utf-8')
        .then(data => {
            return {metadata, contents, tempFile}
        });
};

/**
 * Data object
 * @typedef {Object} Metacontent
 * @property {Object} metadata The template view object
 * @property {String} content The template
 */

/**
 * Parse a file in JSON
 * @param templateFile {String} Path to the template
 * @return {Promise.<Metacontent>}
 */
NodeCF.prototype.readFileJson = function (templateFile) {

    return readFile(templateFile, 'utf-8')
        .then(contents => {

            let index = contents.search(/"Metadata":\s*/) + 10;  // First { after Metadata
            let buffer = [];
            let bracketCounter = 0;
            let char = '';

            do {
                char = contents.charAt(++index);

                buffer.push(char);
                if (char === '{') {
                    bracketCounter++;
                }
                else if (char === '}') {
                    bracketCounter--;
                }

            } while ((bracketCounter !== 0) || (bracketCounter === 0 && char === ' '));

            let dd = buffer.join('');
            let metadata;

            try {
                metadata = JSON.parse(dd);
            }
            catch (err) {
                console.log("********* ERROR *********");
                console.log("Please check this json:");
                console.log(dd);
                throw err;
            }

            return {
                metadata,
                contents
            };
        });

};


NodeCF.prototype.readFileYaml = function(templateFile) {

    return readFile(templateFile, 'utf-8')
        .then(contents => {
            return new Promise((resolve, reject) => {

                // As with JSON, here we care only about the metadata. Don't need to parse the contents,
                // that can be invlaid due to mustache stuff
                const buffer = [];
                const lines = contents.split('\n');
                for(let i=0; i<lines.length; i++) {
                    if(/Resources:/.test(lines[i])){
                        break;
                    }
                    buffer.push(lines[i]);
                }

                const template = YAML.parse(buffer.join('\n'));
                resolve({
                    metadata: template.Metadata,
                    contents: contents
                });
            });
        });
}

/**
 *
 * @param templateFile
 * @param data {Metacontent}
 * @return {Promise.<Metacontent>} Where the metadata keys have been loaded withexternal contents
 */
let __globalcahce = undefined;
NodeCF.prototype.loadExternals = function(templateFile, data){
    const {metadata, contents} = data;

    if(!metadata.aws.__external){
        return data;
    }

    // Grab the base path to the externals
    let temp = templateFile.split('/');
    temp.splice(-1,1);
    const basePath = temp.join('/');

    let extern = [];

    Object.keys(metadata.aws.__external).map(key => {
        const externalFile = `${basePath}/${metadata.aws.__external[key]}`;
        console.log(`Loading external from ${externalFile}`);
        extern.push(
            readFile(externalFile, 'utf-8').then(externalcontents => {

                // Try to indent substack for YAML
                // This is **broken*, eg it doen't allow repetitions. But Elysium need it this way
                if( /ya?ml/.test(path.extname(templateFile)) ) {

                    if(!__globalcahce){
                        __globalcahce = contents.split('\n')
                    }

                    // Find the placeholder using the brackets - match {{key}} and {{{key}}}
                    const daje = __globalcahce.find( (line) => {  return line.indexOf(`{{${key}}}`) > 0; });

                    // Get the indentation
                    const padding = ' '.repeat(daje.search(/\S/));

                    // And waste some CPU cycles
                    // The first element will be put with the indentation of the template.
                    // unshift breaks the chain, returning the LENGTH instead of the new array - lol
                    const lines = externalcontents.split('\n');
                    const head = lines.shift();
                    externalcontents = lines.map(s => `${padding}${s}`);
                    externalcontents.unshift(head);
                    externalcontents = externalcontents.join('\n');
                }

                return {key, externalcontents}
            })
        )
    });

    return Promise.all(extern).then(aContents => {
        aContents.forEach(ext => { metadata.aws.template[ext.key] = ext.externalcontents; });
        return {metadata, contents};
    });
};


/**
 * Apply the view to the template, returning the rendered template
 * @param data {Metacontent}
 * @return {Promise.<String>} The final template
 */
NodeCF.prototype.render = function(data) {
    return new Promise((resolve, reject) => {
        const {metadata, contents} = data;
        resolve({
            metadata,
            contents: Mustache.render(contents,metadata.aws.template)
        });
    });
};

module.exports = NodeCF;
