const fs = require('fs');
const Promise = require("bluebird");
const Mustache = require("mustache")

const readFile = Promise.promisify(require("fs").readFile);
const exec = Promise.promisify(require('child_process').exec);
const writeFile = Promise.promisify(require('fs').writeFile);

/**
 *
 * @param options {object} Config object
 * @param options.inputFile {string} Patht the file with the template to use as input
 * @param options.action {string} Can be "create-stack" or "update-stack"
 * @param options.dryRun {boolean} default TRUE. Call AWS CLoudFormation only if set to false
 * @constructor
 */
function NodeCF(options) {
    this.optons = options;


    /*
     readFile() --> ritorna {contents, metadata}
     loadExternals()
     render()
     saveToTemp()
     createCf()

     */
}

/**
 * Read the input files and return the template generated by mustache
 */
NodeCF.prototype.buildTemplate = function () {
    return this
        .readFileJson(this.optons.inputFile)
        .then(data => {return this.loadExternals(this.optons.inputFile, data)})
        .then(this.render)
};


/**
 * Data object
 * @typedef {Object} Metacontent
 * @property {Object} metadata The template view object
 * @property {String} content The template
 */

/**
 * Parse a file in JSON
 * @param templateFile {String} Path to the template
 * @return {Promise.<Metacontent>}
 */
NodeCF.prototype.readFileJson = function (templateFile) {

    return readFile(templateFile, 'utf-8')
        .then(contents => {

            let index = contents.search(/"Metadata":\s*/) + 10;  // First { after Metadata
            let buffer = [];
            let bracketCounter = 0;
            let char = '';

            do {
                char = contents.charAt(++index);
                buffer.push(char);
                if (char === '{') {
                    bracketCounter++;
                }
                else if (char === '}') {
                    bracketCounter--;
                }
            } while (bracketCounter !== 0);

            let dd = buffer.join('');
            let metadata;

            try {
                metadata = JSON.parse(dd);
            }
            catch (err) {
                console.log("********* ERROR *********");
                console.log('Please verify that there is no blank space in "Metadata":{ ');
                throw err;
            }

            return {
                metadata,
                contents
            };
        });

};

/**
 *
 * @param templateFile
 * @param data {Metacontent}
 * @return {Promise.<Metacontent>} Where the metadata keys have been loaded withexternal contents
 */
NodeCF.prototype.loadExternals = function(templateFile, data){
    const {metadata, contents} = data;

    if(!metadata.aws.__external){
        return data;
    }

    // Grab the base path to the externals
    let temp = templateFile.split('/');
    temp.splice(-1,1);
    const basePath = temp.join('/');

    let extern = [];

    Object.keys(metadata.aws.__external).map(key => {
        const externalFile = `${basePath}/${metadata.aws.__external[key]}`;
        console.log(`Loading external from ${externalFile}`);
        extern.push(
            readFile(externalFile, 'utf-8').then(externalcontents => { return {key, externalcontents} })
        )
    });

    return Promise.all(extern).then(aContents => {
        aContents.forEach(ext => { metadata.aws.template[ext.key] = ext.externalcontents; });
        return {metadata, contents};
    });
};



NodeCF.prototype.render = function(data) {
    return new Promise((resolve, reject) => {
        const {metadata, contents} = data;
        resolve(Mustache.render(contents,metadata.aws.template));
    });
};

module.exports = NodeCF;
